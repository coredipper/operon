\section{Motif 1: Coherent Feed-Forward Loop and Correct Safety Claims}

\subsection{CFFL as Two-Key Execution}

A coherent feed-forward loop has a direct path and an indirect approval path. In agentic systems,
we treat the indirect path as a verifier producing an explicit approval token.

\begin{figure}[h]
\centering
\begin{tikzpicture}[>=Latex, node distance=12mm]
  \node[draw, rounded corners] (X) {Request $X$};
  \node[draw, rounded corners, right=18mm of X] (Z) {Executor $Z$};
  \node[draw, rounded corners, below=10mm of X] (Y) {Verifier $Y$};
  \node[draw, rounded corners, right=18mm of Y] (AND) {$\wedge$ Gate};
  \node[draw, rounded corners, right=18mm of AND] (OUT) {Action};

  \draw[->] (X) -- node[above]{\small Gen} (Z);
  \draw[->] (X) -- (Y);
  \draw[->] (Y) -- node[above]{\small $\Approval$} (AND);
  \draw[->] (Z) -- (AND);
  \draw[->] (AND) -- (OUT);
\end{tikzpicture}
\caption{CFFL as two-key execution: executor output is gated by an approval token.}
\end{figure}

\subsection{The Correct Failure Probability}

We now correct a common but subtle mistake: \emph{an AND gate does not enforce independence}.
It enforces conjunction (both signals required). Independence is an assumption about how errors arise.

\begin{definition}[Error Events]
Let $E_{\mathrm{gen}}$ be the event that the generator/executor path proposes an unsafe or incorrect
action. Let $E_{\mathrm{ver}}$ be the event that the verifier \emph{approves} that unsafe/incorrect action
(i.e., fails to block it).
\end{definition}

\begin{theorem}[CFFL Risk Expression]
In a direct serial execution (no gating), the system fails whenever $E_{\mathrm{gen}}$ occurs:
\[
  \mathbb{P}(\mathrm{Fail}_{\mathrm{direct}}) = \mathbb{P}(E_{\mathrm{gen}}).
\]
In a CFFL with an approval gate, the system fails only when both occur:
\begin{equation}
  \mathbb{P}(\mathrm{Fail}_{\mathrm{CFFL}})
  = \mathbb{P}(E_{\mathrm{gen}} \cap E_{\mathrm{ver}})
  = \mathbb{P}(E_{\mathrm{gen}})\,\mathbb{P}(E_{\mathrm{ver}} \mid E_{\mathrm{gen}}).
  \label{eq:cffl-risk}
\end{equation}
If the verifier catches generator errors with probability $q$, i.e.
$\mathbb{P}(E_{\mathrm{ver}} \mid E_{\mathrm{gen}})=1-q$, then CFFL reduces failure probability
by a factor $(1-q)$ relative to the direct link.
\end{theorem}

\begin{proof}
Direct execution has no second check, so failure is exactly $E_{\mathrm{gen}}$.
In the CFFL, the executor can act only if an approval token is present, so failure requires
(1) an unsafe proposal and (2) verifier approval. The probability identity
$\mathbb{P}(A\cap B)=\mathbb{P}(A)\mathbb{P}(B\mid A)$ yields \eqref{eq:cffl-risk}.
\end{proof}

\begin{remark}[What Topology Guarantees vs What It Does Not]
Topology guarantees an \emph{interlock}: unilateral generator output cannot execute without verifier
approval. Topology does \emph{not} guarantee $\mathbb{P}(E_{\mathrm{ver}} \mid E_{\mathrm{gen}})$ is small.
Reducing that conditional probability requires design choices: model diversity, independent evidence,
tool-based verification, and adversarial testing.
\end{remark}

\subsection{A Topological Guarantee: Two-Key Execution in \texorpdfstring{$\WAgent$}{WAgent}}

\begin{lemma}[Two-Key Execution]
Assume the action sink requires an input port of type $(\Approval,\mathsf{T})$.
Assume the generator path cannot output $(\Approval,\mathsf{T})$ (it outputs at most
$(\mathsf{Text},\mathsf{U})$ or $(\mathsf{ToolCall}(\kappa),\mathsf{V})$).
Then any well-typed wiring diagram that reaches the action sink must include a verifier box that
produces $(\Approval,\mathsf{T})$.
\end{lemma}

\begin{proof}
By $\WAgent$ typing, the action sink must be fed by a wire with exactly the required type and label.
Since the generator cannot produce that port, the only way to satisfy the typing constraints is to
include a box whose output includes $(\Approval,\mathsf{T})$, i.e.\ the verifier.
\end{proof}

\section{Motif 2: Quorum Sensing (Consensus \& Voting)}

Quorum sensing aggregates many weak signals into a robust threshold decision. In agents, this maps to
ensembles and voting.

\begin{remark}[Correlation Warning]
Voting improves reliability when individual errors are not perfectly correlated and when at least a
plurality is better than chance. Shared prompts, shared context poisoning, or a shared misconception
can make errors highly correlated, producing ``confidently wrong'' consensus.
\end{remark}

\paragraph{Design Implication.}
To make quorum useful, inject diversity (different models/temperatures/prompts), incorporate
tool-grounded checks, and consider robust aggregators (weighted voting, abstention, proof-carrying
verifiers).

\section{Motif 3: Chaperones as Partial Validators (Not Retractions)}

Biological chaperones do not implement a perfect inverse; they attempt folding, detect failures,
and route for repair or degradation. The correct software analogue is \emph{partial validation} with
explicit error values.

\begin{definition}[Chaperone Validator (Kleisli Form)]
A chaperone is a Kleisli morphism
\[
  \Val: (\mathsf{Text},\mathsf{U}) \to \Either(\Err, (\mathsf{JSON}(\Sigma),\mathsf{V})).
\]
It either yields a validated structured value or an error trace used for repair.
\end{definition}

\paragraph{Retry \& Repair Loop.}
The generator proposes a structure; the chaperone validates; if invalid, the error is fed back with
bounded retries and a budget box.

\section{Failure Modes as Pathology}

Catastrophic failures often arise not from a single broken component but from dysregulated dynamics.

\subsection{Oncology: Infinite Loops as Unchecked Growth}

\paragraph{Agentic Pathology.}
Agents can enter recursive politeness loops or self-debug loops.

\paragraph{Correct Categorical Diagnosis.}
The problem is not ``distance goes to zero'' in an unspecified metric space. The problem is absence of a
well-founded progress measure and enforced budgets.

\paragraph{Treatment.}
Introduce a guarded trace with:
(1) a step/token budget, and
(2) a ranking function $m(S)\in \mathbb{N}$ that must decrease unless new external evidence arrives.
If $m$ fails to decrease for $k$ steps, trigger apoptosis (termination) or escalation.

\subsection{Autoimmunity: Hallucination Cascades as Integrity Failure}

\paragraph{Agentic Pathology.}
One agent hallucinates; another consumes it from shared memory as if trusted.

\paragraph{Diagnosis.}
This is an integrity-labeling failure: the system does not distinguish untrusted generated text from
validated tool outputs.

\paragraph{Treatment.}
Use integrity labels in $\WAgent$:
tool outputs may be labeled $\mathsf{T}$ (trusted), while generated hypotheses remain $\mathsf{U}$ unless
validated. Require critical decisions to consume $\mathsf{V}$ or $\mathsf{T}$ inputs only.

\subsection{Prion Disease: Prompt Injection as Instruction Contamination}

\paragraph{Agentic Pathology.}
A malicious instruction enters context and influences downstream behavior.

\paragraph{Correct Mechanism Statement.}
Propagation is primarily due to \emph{context mixing and instruction-following} across trust boundaries,
not ``pure geometry'' alone.

\paragraph{Diagnosis.}
An information-flow policy is violated: untrusted text affects privileged control decisions.

\paragraph{Treatment.}
\begin{itemize}[leftmargin=*]
  \item \textbf{Noninterference by construction:} require privileged actions to be gated by
  $(\Approval,\mathsf{T})$ tokens and/or tool-grounded evidence.
  \item \textbf{Sanitization layers:} $\San: (\mathsf{Text},\mathsf{U}) \to (\mathsf{Text},\mathsf{U})$ that removes
  tool-like syntax, policy-violating directives, or embedded prompts (useful but not sufficient alone).
  \item \textbf{Capability least-privilege:} restrict which boxes possess capabilities like $\mathsf{Net}$,
  $\mathsf{WriteFS}$, or $\mathsf{Money}$; require explicit escalation paths.
\end{itemize}

\subsection{Ischemia: Resource Exhaustion}

\paragraph{Agentic Pathology.}
Token starvation, rate limits, latency spikes.

\paragraph{Diagnosis.}
Every wiring-diagram operation consumes resources. Static reasoning can bound \emph{structural} fan-out
and maximum loop iterations, but dynamic effects (model variability, tool delays) require runtime
enforcement.

\paragraph{Treatment.}
A resource-aware runtime enforces token budgets and timeouts. The compiler can reject architectures
that contain \emph{unguarded} trace, but cannot in general compute exact bounds for unconstrained
LLM-driven stopping conditions.

